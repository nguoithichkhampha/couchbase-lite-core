//
// Document.cc
//
// Copyright (c) 2017 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "Document.hh"
#include "c4Document+Fleece.h"
#include "StringUtil.hh"
#include "Fleece.hh"

using namespace fleece;

namespace c4Internal {

    bool Document::isOldMetaProperty(slice key) {
        return (key.size > 0 && key[0] == '_');
    }


    // Returns true if a Fleece Dict contains any top-level keys that begin with an underscore.
    bool Document::hasOldMetaProperties(const Dict* root) {
        for (Dict::iterator i(root); i; ++i) {
            if (isOldMetaProperty(i.keyString()))
                return true;
        }
        return false;
    }


    // Copies an _attachments dict to the encoder, but skips the entries that are shadows of blob
    // objects. If all entries are skipped, doesn't write an `_attachments` dictionary at all.
    static void encodeNonShadowAttachments(Encoder &e, const Dict *attachments) {
        bool createdDict = false;
        for (Dict::iterator ai(attachments); ai; ++ai) {
            slice akey = ai.keyString();
            if (!akey.hasPrefix("blob_"_sl)) {  // skip shadows generated during encoding
                //FIX: The above test is a bit naive, and it hardcodes knowledge of the
                // attachment names generated by DBWorker's encoder. Instead, I should look through
                // the document and find all the blobs' digests, then compare this attachment's
                // digest to see if it matches any of them.
                if (!createdDict) {
                    e.writeKey(kC4LegacyAttachmentsProperty);
                    e.beginDictionary();
                    createdDict = true;
                }
                e.writeKey(akey);
                e.writeValue(ai.value());
            }
        }
        if (createdDict)
            e.endDictionary();
    }


    // Encodes a document Dict, skipping top-level properties whose names begin with an underscore.
    alloc_slice Document::encodeStrippingOldMetaProperties(const Dict* root) {
        Encoder e;
        e.beginDictionary(root ? root->count() : 0);
        for (Dict::iterator i(root); i; ++i) {
            slice key = i.keyString();
            if (isOldMetaProperty(key)) {
                if (key == slice(kC4LegacyAttachmentsProperty)) {
                    // Old-style _attachments property. We have to preserve any of its attachments
                    // that are not simply shadowing blobs elsewhere in the document:
                    encodeNonShadowAttachments(e, i.value()->asDict());
                }
            } else {
                e.writeKey(key);
                e.writeValue(i.value());
            }
        }
        e.endDictionary();
        return e.extractOutput();
    }


    // Finds blob references in a Fleece value, recursively.
    // Return value of false means the callback stopped the iteration (by returning false.)
    bool Document::findBlobReferences(const Value *val, SharedKeys* sk, const FindBlobCallback &callback) {
        auto d = val->asDict();
        if (d) {
            return findBlobReferences(d, sk, callback);
        }
        auto a = val->asArray();
        if (a) {
            for (Array::iterator i(a); i; ++i)
                if (!findBlobReferences(i.value(), sk, callback))
                    return false;
        }
        return true;
    }


    slice Document::dictIsBlob(const Dict *dict, SharedKeys* sk) {
        const Value* cbltype= dict->get(C4STR(kC4ObjectTypeProperty), sk);
        if (!cbltype || cbltype->asString() != slice(kC4ObjectType_Blob))
            return nullslice;
        const Value* digest = ((const Dict*)dict)->get("digest"_sl, sk);
        if (!digest)
            return nullslice;
        return digest->asString();
    }


    bool Document::dictIsBlob(const Dict *dict, blobKey &outKey, SharedKeys* sk) {
        slice digest = dictIsBlob(dict, sk);
        return digest && outKey.readFromBase64(digest);
    }


    // Finds blob references in a Fleece Dict, recursively.
    bool Document::findBlobReferences(const Dict *dict, SharedKeys* sk, const FindBlobCallback &callback)
    {
        if (dict->get(C4STR(kC4ObjectTypeProperty), sk)) {
            if (dictIsBlob(dict, sk))
                return callback(dict);
        } else {
            for (Dict::iterator i(dict); i; ++i) {
                if (!findBlobReferences(i.value(), sk, callback))
                    return false;
            }
        }
        return true;
    }


    void Document::findBlobReferencesAndKeys(const Dict *dict, SharedKeys* sk,
                                             const FindBlobWithKeyCallback &callback)
    {
        findBlobReferences(dict, sk, [=](const Dict *blob) {
            blobKey key;
            if (dictIsBlob(blob, key, sk)) {
                auto lengthVal = blob->get("length"_sl, sk);
                uint64_t length = lengthVal ? lengthVal->asUnsigned() : 0;
                callback(key, length);
            }
            return true;
        });
    }


    bool Document::isValidDocID(slice docID) {
        return docID.size >= 1 && docID.size <= 240 && docID[0] != '_'
            && isValidUTF8(docID) && hasNoControlCharacters(docID);
    }

    void Document::requireValidDocID() {
        if (!isValidDocID(docID))
            error::_throw(error::BadDocID, "Invalid docID \"%.*s\"", SPLAT(docID));
    }


    // Heuristics for deciding whether a MIME type is compressible or not.
    // See <http://www.iana.org/assignments/media-types/media-types.xhtml>

    // These substrings in a MIME type mean it's definitely not compressible:
    static const slice kCompressedTypeSubstrings[] = {
        "zip"_sl,
        "zlib"_sl,
        "pkcs"_sl,
        "mpeg"_sl,
        "mp4"_sl,
        "crypt"_sl,
        ".rar"_sl,
        "-rar"_sl,
        {}
    };

    // These substrings mean it is compressible:
    static const slice kGoodTypeSubstrings[] = {
        "json"_sl,
        "html"_sl,
        "xml"_sl,
        "yaml"_sl,
        {}
    };

    // These prefixes mean it's not compressible, unless it matches the above good-types list
    // (like SVG (image/svg+xml), which is compressible.)
    static const slice kBadTypePrefixes[] = {
        "image/"_sl,
        "audio/"_sl,
        "video/"_sl,
        {}
    };

    static bool containsAnyOf(slice type, const slice types[]) {
        for (const slice *t = &types[0]; *t; ++t)
            if (type.find(*t))
                return true;
        return false;
    }


    static bool startsWithAnyOf(slice type, const slice types[]) {
        for (const slice *t = &types[0]; *t; ++t)
            if (type.hasPrefix(*t))
                return true;
        return false;
    }

    bool Document::blobIsCompressible(const Dict *meta, SharedKeys *sk) {
        // Don't compress an attachment with a compressed encoding:
        auto encodingProp = meta->get("encoding"_sl, sk);
        if (encodingProp && containsAnyOf(encodingProp->asString(), kCompressedTypeSubstrings))
            return false;

        // Don't compress attachments with unknown MIME type:
        auto typeProp = meta->get("content_type"_sl, sk);
        if (!typeProp)
            return false;
        slice type = typeProp->asString();
        if (!type)
            return false;

        // Check the MIME type:
        string lc = type.asString();
        toLowercase(lc);
        type = lc;
        if (containsAnyOf(type, kCompressedTypeSubstrings))
            return false;
        else if (type.hasPrefix("text/"_sl) || containsAnyOf(type, kGoodTypeSubstrings))
            return true;
        else if (startsWithAnyOf(type, kBadTypePrefixes))
            return false;
        else
            return true;
    }

}
